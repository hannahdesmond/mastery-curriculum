
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Classes Â· Mastery Curriculum</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="Mary Rose Cook and Sam Morgan">
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-accordion/accordion.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-disqus/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    
    <link rel="prev" href="../chapter9/" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../INSTRUCTIONS.html">
            
                <a href="../INSTRUCTIONS.html">
            
                    
                    Instructions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../chapter1/">
            
                <a href="../chapter1/">
            
                    
                    Hello World
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../chapter2/">
            
                <a href="../chapter2/">
            
                    
                    Variables and Statements
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../chapter3/">
            
                <a href="../chapter3/">
            
                    
                    Messages and Interfaces
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../chapter4/">
            
                <a href="../chapter4/">
            
                    
                    Flow of Control
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../chapter5/">
            
                <a href="../chapter5/">
            
                    
                    Other Objects
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../chapter6/">
            
                <a href="../chapter6/">
            
                    
                    Advanced Flow of Control
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../chapter7/">
            
                <a href="../chapter7/">
            
                    
                    Arrays
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="../chapter8/">
            
                <a href="../chapter8/">
            
                    
                    Hashes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="../chapter9/">
            
                <a href="../chapter9/">
            
                    
                    Methods
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.12" data-path="./">
            
                <a href="./">
            
                    
                    Classes
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Classes</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="writing-your-own-classes">Writing your own Classes</h1>
<p>We&apos;ve been spending a lot of time writing complex procedures. We&apos;ve spent a lot of time <em>telling program objects how to get to the answer</em>:</p>
<pre><code class="lang-eval-ruby"># set up some scores
scores = [19, 17, 12]

# make an accumulator
accumulator = 0

# start a loop
scores.each do |score|
  # accumulate each score
  accumulator += score
end

# divide the accumulator, as a float, by the number of scores
accumulator.to_f / scores.length
</code></pre>
<ul>
<li><em>Telling an object how to get to the answer</em> might look like: &quot;create an accumulator. Add the scores to it. Then divide them.&quot; This is called <strong>imperative</strong> programming &#x2013; literally, &apos;ordering the computer to do things&apos;.</li>
</ul>
<p>In <a href="../chapter9/">Chapter 9</a>, we started seeing how we could take these imperative procedures and hide them behind <em>method names</em>. This means that our code looks more like <em>telling an object what we want</em>, by interacting with abstractions:</p>
<pre><code class="lang-ruby"><span class="hljs-comment"># average some scores, please</span>
average(scores)
</code></pre>
<ul>
<li><em>Telling an object what we want</em> might look like &quot;average these scores.&quot; This is called <strong>declarative</strong> programming &#x2013; literally, &apos;saying what we would like to happen&apos;.</li>
</ul>
<p>When we&apos;re writing complex procedures, we&apos;re often working in a very <em>imperative</em> world. We&apos;re handling things like <em>control flow</em> with <em>conditionals</em> and <em>loops</em>, working with simple objects like <em>arrays</em>, <em>strings</em>, <em>hashes</em>, and <em>integers</em>. It&apos;s a tough world, and it&apos;s quite unfriendly to non-programmers (and unfriendly to programmers who didn&apos;t write the procedure themselves).</p>
<p>Therefore, as programmers, we try to abstract our work to a declarative style wherever possible. This is why, back in <a href="../chapter1/">Chapter 1</a>, we were first introduced to the &apos;program world&apos;: because it&apos;s a declarative world, where you can ask <code>1</code> if it&apos;s an integer:</p>
<pre><code class="lang-eval-ruby">1.integer?
</code></pre>
<p>And it&apos;ll just <em>tell you the answer</em>. Sure, there&apos;s probably some imperative procedure going on under the hood. In fact, there <em>definitely is</em>. But we don&apos;t have to know about it. That frees us up to think about more high-level program concerns, like how to meet a particular requirement.</p>
<p>These are the kinds of worlds we strive to create as programmers. One very popular route to doing so is to use <strong>Object-Oriented Programming</strong>. We&apos;ve met a bunch of this already, but here&apos;s a quick refresher:</p>
<pre><code class="lang-eval-ruby"># String is a class &#x2013; an object in the program world.
# When we send the message &apos;new&apos; to it, the class figures out how to make an instance
# my_string is an instance of the String class. It&apos;s also an object in the program world: a new one
my_string = String.new(&quot;Hello World&quot;)

# We can tell my_string to do things, declaratively
# Here, we&apos;ll tell my_string to return its text in uppercase
# We don&apos;t really have to care about how the computer makes this happen
# (maybe it iterates through the list of characters and upcases each one?)
# All we care about is that it&apos;s easy to do
my_string.upcase
</code></pre>
<p>In this chapter, we&apos;ll learn how to move from an imperative to a declarative world, by: </p>
<ul>
<li>defining new methods on object interfaces, then </li>
<li>defining whole new objects.</li>
</ul>
<h2 id="back-to-the-program-world">Back to the program world</h2>
<p>Remember our view of the program world:</p>
<objects interacting="" in="" the="" program="" world="">

<p>In particular, remember where all the complex imperative procedures we&apos;ve been writing are actually running:</p>
<zoom in="" on="" object="" interface="" to="" reveal="" methods="" working="" 'inside'="">

<p>Procedures are running <em>inside methods</em>. We learned how to write methods in <a href="../chapter9/">Chapter 9</a> &#x2013; but the methods we defined weren&apos;t obviously part of any given object&apos;s interface. So where have they been living?</p>
<h2 id="global-scope">Global scope</h2>
<p>In <a href="../chapter3/">Chapter 3</a>, we learned that whenever you send a message to an object <em>without specifying the object</em>, that message is sent to the main program object:</p>
<pre><code class="lang-eval-ruby">+(3)
</code></pre>
<p>So, for the past few chapters we&apos;ve been defining all of our procedures on the main program object. When we write:</p>
<pre><code class="lang-eval-ruby">players = [
  { :name =&gt; &quot;Sam&quot;, :sport =&gt; &quot;tennis&quot; },
  { :name =&gt; &quot;Mary&quot;, :sport =&gt; &quot;squash&quot; },
  { :name =&gt; &quot;Ed&quot;, :sport =&gt; &quot;tennis&quot; },
  { :name =&gt; &quot;Mark&quot;, :sport =&gt; &quot;football&quot; }
]

players_by_sport = {}

players.each do |player|
  sport = player[:sport]

  if players_by_sport[sport] == nil
    players_by_sport[sport] = []
  end

  players_by_sport[sport].push(player[:name])
end

players_by_sport
</code></pre>
<p>...we&apos;re asking the main program object to do all this work. We&apos;re instructing the universe directly. </p>
<p>In <a href="../chapter9/">Chapter 9</a>, when we moved the averaging procedure into the method named <code>average</code>:</p>
<pre><code class="lang-eval-ruby">def average(scores)
  scores_accumulator = 0

  scores.each do |score|
    scores_accumulator += score
  end

  scores_accumulator.to_f / scores.length
end
</code></pre>
<p>We defined this <code>average</code> method <em>on the main object</em>.</p>
<blockquote>
<p>In Ruby, there are no &apos;objectless methods&apos;.</p>
</blockquote>
<h2 id="defining-methods-on-objects">Defining methods on objects</h2>
<p>Remember that the main program object is an <em>instance of the <code>Object</code> class</em>. Here&apos;s how we&apos;d define the <code>average</code> method on the main object formally:</p>
<pre><code class="lang-eval-ruby">class Object
  def average(scores)
    scores_accumulator = 0

    scores.each do |score|
      scores_accumulator += score
    end

    scores_accumulator.to_f / scores.length
  end
end

average([1, 2, 3])
</code></pre>
<blockquote>
<p>Notice that we&apos;re <em>opening up the class</em> to fiddle with its insides. We&apos;re essentially <em>rewiring the gods</em> so they create slightly different kinds of things.</p>
</blockquote>
<p>The above simply a more formal way of writing:</p>
<pre><code class="lang-eval-ruby">def average(scores)
  scores_accumulator = 0

  scores.each do |score|
    scores_accumulator += score
  end

  scores_accumulator.to_f / scores.length
end
</code></pre>
<p>Because, by default, <em>methods are defined on the main object</em>.</p>
<p>How about if we wanted to define a method on another object? Say, something that would allow us to do:</p>
<pre><code class="lang-irb">&gt; my_object = <span class="hljs-string">&quot;A string!&quot;</span>
&gt; my_object.say_hi
=&gt; <span class="hljs-string">&quot;Hi there!&quot;</span>
</code></pre>
<p>That is: when we send the message <code>say_hi</code> to a string, it should return <code>&quot;Hi there!&quot;</code>.</p>
<p><code>say_hi</code> is not, by default, part of the instance methods available to strings. So, we have to define it, just like we did the <code>average</code> method on <code>Object</code> instances:</p>
<pre><code class="lang-eval-ruby">class String
  def say_hi
    &quot;Hi there!&quot;
  end
end

my_object = &quot;A string!&quot;
my_object.say_hi
</code></pre>
<blockquote>
<p>Again: we&apos;re <em>opening the String class</em> to fiddle with the kinds of objects it creates. In this case, we&apos;re telling the <code>String</code> class: &quot;when you create instances, make sure they have this method, too&quot;.</p>
</blockquote>
<ul>
<li><em><strong>Define another method on the string above, called <code>say_hi_to</code>. It should take one argument, a name. It should return &quot;Hi, <name>!&quot;</name></strong></em></li>
</ul>
<h2 id="using-object-state-in-methods">Using object state in methods</h2>
<p>Let&apos;s do something useful with this information. Our <code>average</code> method would be even more ace if we could just go:</p>
<pre><code class="lang-ruby">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].average
</code></pre>
<blockquote>
<p><code>[1, 2, 3].average</code> feels far more declarative than <code>average([1, 2, 3])</code>. It uses the familiar dot syntax, too.</p>
</blockquote>
<p>To do this, we need to define a new method on <code>Array</code> instances:</p>
<pre><code class="lang-eval-ruby">class Array
  def average
    # Somehow, do the averaging in here
  end
end
</code></pre>
<p>But we have a problem &#x2013; in order to average an array of number elements, we need access to those elements. Instances of the <code>Array</code> class know about their own elements: but how can we access them?</p>
<p>Enter the Ruby keyword <code>self</code>. <code>self</code> refers to the &apos;current object we&apos;re inside&apos;. So, when we&apos;re messing around defining methods on <code>Array</code> instances, <code>self</code> refers to the instance.</p>
<pre><code class="lang-eval-ruby">class Array
  def average
    return self
  end
end

[1, 2, 3].average
</code></pre>
<blockquote>
<p>Notice that we get the array instance itself back when we call <code>self</code>.</p>
</blockquote>
<p>We can use <code>self</code> to access the array instance&apos;s own elements, and average them:</p>
<pre><code class="lang-eval-ruby">class Array
  def average
    accumulator = 0

    self.each do |element|
      accumulator += element
    end

    accumulator.to_f / self.length
  end
end

[1, 2, 3].average
</code></pre>
<ul>
<li><em><strong>Define a method on string instances, called <code>shoutify</code>. This method should return the string text in uppercase, with an extra exclamation mark on the end. In other words, <code>&quot;hello world&quot;.shoutify</code> should return <code>&quot;HELLO WORLD!&quot;</code>.</strong></em></li>
</ul>
<h2 id="defining-your-own-classes">Defining your own classes</h2>
<p>We&apos;ve just seen how to use the <code>class</code> keyword to &apos;re-open&apos; existing classes and mess around with the instances they make. We can also use this <code>class</code> keyword to define entirely new classes &#x2013; new gods &#x2013; each of which can create whole new instances.</p>
<p>We&apos;re going to try and build the following program:</p>
<pre><code class="lang-ruby">fido = Dog.new

fido.bark
<span class="hljs-comment"># We should see &quot;Woof!&quot;</span>
</code></pre>
<p>We can actually let our error messages tell us what to do at each stage. This is a helpful way to figure out what we need to do next, step-by-step. Let&apos;s try running our program as-is:</p>
<pre><code class="lang-eval-ruby">fido = Dog.new
fido.bark
</code></pre>
<p>OK, we have an error: <code>uninitialized constant Dog</code>. What&apos;s this telling us? It&apos;s saying &quot;I couldn&apos;t find a name &apos;Dog&apos;&quot;. Let&apos;s make one!</p>
<pre><code class="lang-eval-ruby">Dog = &quot;a dog&quot;

fido = Dog.new
fido.bark
</code></pre>
<p>I did the simplest thing, and we have a new, explanative error. Apparently the <code>String</code> instance I made, <code>&quot;a dog&quot;</code>, doesn&apos;t respond to <code>new</code>. It sounds like we need <code>Dog</code> to be some kind of object that responds to <code>new</code>.</p>
<p>What objects respond to <code>new</code>? Classes! It turns out that Ruby has a class called <code>Class</code>. It&apos;s the god of classes! Instances of the <code>Class</code> class are, well, classes. We can send <code>new</code> to it, and get a new class in response:</p>
<pre><code class="lang-eval-ruby">Dog = Class.new

fido = Dog.new
fido.bark
</code></pre>
<p>We&apos;ve just defined a new class, <code>Dog</code>. However, we haven&apos;t added any methods to it. Let&apos;s do that, using the technique we used before with <code>Object</code>, <code>Array</code>, and <code>String</code>:</p>
<pre><code class="lang-eval-ruby">Dog = Class.new

class Dog
  def bark
    return &quot;Woof&quot;
  end
end

fido = Dog.new
fido.bark
</code></pre>
<p>And that&apos;s how we define new kinds of object, and new methods on those objects.</p>
<p>We&apos;ve seen so far that the <code>class</code> keyword is shorthand for &quot;open up this class, and do things with it&quot;. It&apos;s actually a bit cleverer than this. If the class given to <code>class</code> doesn&apos;t exist, it will be made on-the-fly. That means we can tighten the example above down to:</p>
<pre><code class="lang-eval-ruby">class Dog
  def bark
    return &quot;Woof&quot;
  end
end

fido = Dog.new
fido.bark
</code></pre>
<p>This is a more common way to define new kinds of object (and methods on them) in Ruby.</p>
<ul>
<li><em><strong>Add another method to the <code>Dog</code> class.</strong></em></li>
</ul>
<h2 id="object-properties">Object properties</h2>
<p>Remember how <code>1</code> knows about its value (1)? And how instances of <code>String</code> know about some text? These things are both examples of <strong>object state</strong>. In fact, a string&apos;s internal characters are referred to as <strong>properties</strong> of the string.</p>
<p>Let&apos;s upgrade our Dog class. We&apos;d love to be able to do something like this:</p>
<pre><code class="lang-ruby">fido = Dog.new

fido.colour = <span class="hljs-string">&quot;brown&quot;</span>

fido.observe
<span class="hljs-comment"># returns &quot;You see a brown dog.&quot;</span>
</code></pre>
<p>Moreover, we&apos;d love to be able to do something like this:</p>
<pre><code class="lang-ruby">fido = Dog.new
chelsea = Dog.new

fido.colour = <span class="hljs-string">&quot;brown&quot;</span>
chelsea.colour = <span class="hljs-string">&quot;white&quot;</span>

fido.observe
<span class="hljs-comment"># returns &quot;You see a brown dog.&quot;</span>

chelsea.observe
<span class="hljs-comment"># returns &quot;You see a white dog.&quot;</span>

fido.observe
<span class="hljs-comment"># returns &quot;You see a brown dog.&quot;</span>
</code></pre>
<p>That is: we want instances of the <code>Dog</code> class &#x2013; dog objects &#x2013; to:</p>
<ul>
<li>Respond to a method <code>colour =</code> by setting a property on themselves</li>
<li>Respond to a method <code>observe</code> with a string</li>
<li>Vary that string according to the colour property</li>
<li>Remember what colour they are, so they always return &apos;their&apos; string</li>
</ul>
<p>We already know how to define new methods on <code>Dog</code>, so let&apos;s allow our errors to guide us:</p>
<pre><code class="lang-eval-ruby">class Dog
  def bark
    return &quot;Woof!&quot;
  end
end

fido = Dog.new
fido.colour = &quot;brown&quot;
fido.observe
</code></pre>
<p>We get a useful error: <code>colour=: undefined method &apos;colour=&apos; for #&lt;Dog:0x1b210&gt;</code>. (Your memory address, &apos;0x1b210&apos; bit, will probably differ from mine.)</p>
<blockquote>
<p>In <a href="../chapter5/">Chapter 5</a>, we found out that the <code>0x1b210</code> (or whatever number you have) is a <em>hexadecimal number</em> referencing the memory address of the dog instance.</p>
</blockquote>
<p>We can fix this by simply doing as we&apos;re told: defining a method <code>colour=</code> on dog instances:</p>
<pre><code class="lang-eval-ruby">class Dog
  def bark
    return &quot;Woof!&quot;
  end

  def colour=
  end
end

fido = Dog.new
fido.colour = &quot;brown&quot;
fido.observe
</code></pre>
<p>Now we have a new error: <code>undefined method &apos;observe&apos; for #&lt;Dog:0x1b210&gt;</code>. We can fix this in the same way:</p>
<pre><code class="lang-eval-ruby">class Dog
  def bark
    return &quot;Woof!&quot;
  end

  def colour=
  end

  def observe
  end
end

fido = Dog.new
fido.colour = &quot;brown&quot;
fido.observe
</code></pre>
<blockquote>
<p>Notice that we&apos;re not doing anything with the methods, yet. We&apos;re just defining them to get rid of the errors.</p>
</blockquote>
<p>OK! Now we don&apos;t see any more errors. But &#x2013; at the moment, <code>observe</code> just returns <code>nil</code>.</p>
<blockquote>
<p>Remember, empty method procedures just return <code>nil</code> in Ruby.</p>
</blockquote>
<p>Let&apos;s fix that with the string we want:</p>
<pre><code class="lang-eval-ruby">class Dog
  def bark
    return &quot;Woof!&quot;
  end

  def colour=
  end

  def observe
    return &quot;You see a brown dog.&quot;
  end
end

fido = Dog.new
fido.colour = &quot;brown&quot;
fido.observe
</code></pre>
<p>Awesome! Does this work for <code>chelsea</code>, the white dog, too?</p>
<pre><code class="lang-eval-ruby">class Dog
  def bark
    return &quot;Woof!&quot;
  end

  def colour=
  end

  def observe
    return &quot;You see a brown dog.&quot;
  end
end

chelsea = Dog.new
chelsea.colour = &quot;white&quot;
chelsea.observe
</code></pre>
<p>Ah, the program still suggests that Chelsea is a brown dog. We need to make the program vary according to the colour we provide: we need some way for the <code>Dog</code> instance to remember the colour we give it.</p>
<p>Here&apos;s how Ruby objects can be told to remember values:</p>
<pre><code class="lang-eval-ruby">class Dog
  def bark
    return &quot;Woof!&quot;
  end

  def colour=(colour)
    @colour = colour
  end

  def observe
    return &quot;You see a &quot; + @colour + &quot; dog.&quot;
  end
end

chelsea = Dog.new
chelsea.colour = &quot;white&quot;
chelsea.observe
</code></pre>
<p>The above code will work for both Fido and Chelsea. That&apos;s because we&apos;re saving the colour property, passed as an argument to the <code>colour=</code> method, to the object state. To save things to the object state, we use an <strong>instance variable</strong>.</p>
<p>Let&apos;s look more closely at what the <code>colour=</code> method is doing:</p>
<pre><code class="lang-eval-ruby">def colour=(colour)
  @colour = colour
end
</code></pre>
<ul>
<li>In line 1, we define a new method <code>colour=</code>. It takes one argument, which we name <code>colour</code>.</li>
<li>In line 2, we set up a new name, <code>@colour</code>, and assign it to the <code>colour</code> parameter of the <code>colour=</code> method.</li>
<li>In line 3, we close the <code>colour=</code> method.</li>
</ul>
<p>Let&apos;s give another example of this.</p>
<pre><code class="lang-eval-ruby">class Person
  def give_a_name(name)
    @my_name = name
  end

  def introduce
    return &quot;Hello, I&apos;m &quot; + @my_name
  end
end

woman = Person.new
woman.give_a_name(&quot;Yasmin&quot;)
woman.introduce
</code></pre>
<p>In the example above, we:</p>
<ul>
<li>define a <code>Person</code> class with some methods.</li>
<li>assign a new instance of <code>Person</code> to the variable <code>woman</code>.</li>
<li>Set the property <code>@my_name</code> on the <code>Person</code> instance referenced by <code>woman</code> to a new string, <code>&quot;Yasmin&quot;</code>.</li>
<li>Call the <code>introduce</code> method on the <code>Person</code> instance referenced by <code>woman</code>, which returns a string, <code>&quot;Hello, I&apos;m Yasmin&quot;</code>.</li>
</ul>
<blockquote>
<p>Look closer at the method <code>give_me_a_name</code>. We can call the parameter <code>name</code> whatever we want, so long as we reference that same parameter in the method procedure.</p>
</blockquote>
<p>The following code will do exactly the same thing: but I&apos;ve changed some of the variable and method names around to make a point:</p>
<pre><code class="lang-eval-ruby">class Person
  def call_me(nickname)
    @name_i_would_like_to_be_known_by = nickname
  end

  def introduce
    return &quot;Hello, I&apos;m &quot; + @name_i_would_like_to_be_known_by
  end
end

woman = Person.new
woman.call_me(&quot;Yasmin&quot;)
woman.introduce
</code></pre>
<p>Since we&apos;re free to name variables and methods as we wish, the most sensible implementation of <code>Person</code> would use nice, terse names:</p>
<pre><code class="lang-eval-ruby">class Person
  def name=(name)
    @name = name
  end

  def introduce
    return &quot;Hello, I&apos;m &quot; + @name
  end
end

woman = Person.new
woman.name=(&quot;Yasmin&quot;)
woman.introduce
</code></pre>
<blockquote>
<p>Using Ruby&apos;s syntactic sugar, we can replace the penultimate line with <code>woman.name = &quot;Yasmin&quot;</code>.</p>
</blockquote>
<p>Methods that set object state &#x2013; like <code>name=</code> above &#x2013; are called <strong>setters</strong>. We&apos;ve seen that setter methods can be called anything you like (<code>call_me</code> is a setter, <code>give_me_a_name</code> is a setter, and <code>name=</code> is a setter): the important thing is that they <em>set object state using an instance variable</em>.</p>
<h2 id="mutating-object-state">Mutating object state</h2>
<p>We can change object state, too. Let&apos;s build the following program:</p>
<pre><code class="lang-ruby">robot = Robot.new
robot.legs = <span class="hljs-number">4</span>

robot.add_leg
robot.add_leg

robot.walk
<span class="hljs-comment"># returns &quot;I&apos;m walking on my 6 legs!&quot;</span>
</code></pre>
<p>We already know how to build out the first (<code>legs=</code>) and the last (<code>walk</code>) parts:</p>
<pre><code class="lang-eval-ruby">class Robot
  def legs=(number_of_legs)
    @number_of_legs = number_of_legs
  end

  def walk
    return &quot;I&apos;m walking on my &quot; + @number_of_legs.to_s + &quot; legs!&quot;
  end
end

robot = Robot.new
robot.legs = 4
robot.walk
</code></pre>
<p>How does <code>add_leg</code> work, though? We&apos;re changing a the <code>@legs</code> property of the <code>Robot</code> instance. </p>
<p>Remember <code>+=</code>?</p>
<pre><code class="lang-eval-ruby">class Robot
  def legs=(number_of_legs)
    @number_of_legs = number_of_legs
  end

  def add_leg
    @number_of_legs += 1
  end

  def walk
    return &quot;I&apos;m walking on my &quot; + @number_of_legs.to_s + &quot; legs!&quot;
  end
end

robot = Robot.new
robot.legs = 4

robot.add_leg
robot.add_leg

robot.walk
</code></pre>
<h2 id="using-initialize-to-set-up-instances">Using <code>initialize</code> to set up instances</h2>
<p>Imagine if <code>String</code> instances worked like this:</p>
<pre><code class="lang-ruby">my_string = String.new
string.text = <span class="hljs-string">&quot;Some text&quot;</span>
</code></pre>
<p>How annoying that would be! And yet, thanks to our obsession with setter methods above, that&apos;s exactly what we&apos;re doing with our <code>Dog</code>, <code>Person</code>, and <code>Robot</code> classes. Wouldn&apos;t it be better to write:</p>
<pre><code class="lang-ruby">woman = Person.new(<span class="hljs-string">&quot;Yasmin&quot;</span>)
</code></pre>
<p>Just like we write <code>my_string = String.new(&quot;Some text&quot;)</code>?</p>
<p>We can! Thanks to Ruby <strong>initializers</strong>.</p>
<p>In Ruby, whenever we call <code>new</code> on a class, that class builds an object and then runs the method <code>initialize</code> on it:</p>
<diagram of="" the="" `new`="" and="" `initialize`="" process="">

<p>If we want to store information about an object as part of that object&apos;s state &#x2013; as a property on the object &#x2013; we need to interfere with this <code>initialize</code> method.</p>
<blockquote>
<p>Ruby automatically defines the <code>initialize</code> method, even if you don&apos;t write it. That&apos;s why <code>new</code> still worked for our <code>Dog</code>, <code>Person</code>, and <code>Robot</code> classes before.</p>
</blockquote>
<pre><code class="lang-eval-ruby">class Dog
  def initialize
    puts &quot;I&apos;m initializing a dog!&quot;
  end
end

fido = Dog.new
</code></pre>
<p>Every argument to the <code>new</code> function is passed to the <code>initialize</code> function. Therefore, if we want to send the string <code>&quot;brown&quot;</code> or <code>&quot;white&quot;</code> to be stored on a dog as soon as we call <code>new</code>, we need to set an instance variable in the initializer.</p>
<pre><code class="lang-eval-ruby">class Dog
  def initialize(colour)
    @colour = colour
  end

  def observe
    &quot;You see a &quot; + @colour + &quot; dog.&quot;
  end
end

fido = Dog.new(&quot;brown&quot;)
fido.observe
</code></pre>
<p>No setter method needed! Let&apos;s do that again, with our <code>Person</code> class:</p>
<pre><code class="lang-eval-ruby">class Person
  def initialize(name)
    @name = name
  end

  def introduce
    return &quot;Hello, I&apos;m &quot; + @name
  end
end

woman = Person.new(&quot;Yasmin&quot;)
woman.introduce
</code></pre>
<p>And once more, with our <code>Robot</code> class:</p>
<pre><code class="lang-eval-ruby">class Robot
  def initialize(number_of_legs)
    @number_of_legs = number_of_legs
  end

  def add_leg
    @number_of_legs += 1
  end

  def walk
    return &quot;I&apos;m walking on my &quot; + @number_of_legs.to_s + &quot; legs!&quot;
  end
end

robot = Robot.new(4)

robot.add_leg
robot.add_leg

robot.walk
</code></pre>
<p>By using multiple parameters with <code>initialize</code>, we can provide multiple pieces of information to an object at once:</p>
<pre><code class="lang-eval-ruby">class Person
  def initialize(name, age)
    @name = name
    @age = age
  end

  def introduce
    &quot;Hello, I&apos;m &quot; + @name + &quot;, and I&apos;m &quot; + @age.to_s + &quot; years old.&quot;
  end

  def get_older
    @age += 1
  end
end

peter = Person.new(&quot;Peter&quot;, 17)
peter.get_older

peter.introduce
</code></pre>
<h2 id="different-kinds-of-variables">Different kinds of variables</h2>
<p>All variables are references to objects in Ruby &#x2013; because everything is an object: from <code>1</code>, to <code>&quot;Hello world&quot;</code>, to the <code>Dog</code> class.</p>
<p>So far, we&apos;ve met a few different kinds of variables:</p>
<ul>
<li>Regular variables, like <code>my_string = &quot;Hello World</code></li>
<li>Constants, like <code>ONE = 1</code></li>
<li>Variables inside methods, which get their names from parameters, like <code>scores</code> in our <code>average</code> method</li>
<li>Instance variables, like <code>@name</code>, <code>@colour</code> and <code>@legs</code>.</li>
</ul>
<p>What&apos;s the difference between these kinds of variables? They answer is, broadly speaking, <em>which objects can see them</em>.</p>
<h4 id="what-can-see-an-instance-variable">What can see an instance variable?</h4>
<p><strong>Instance variables</strong> are the simplest: they can only be seen by the object that they&apos;re &apos;inside&apos;:</p>
<pre><code class="lang-eval-ruby">class Dog
  def initialize(colour)
    @colour = colour
  end

  # We can use @colour in any methods defined on Dog instances
  # Such as this one
  def observe
    &quot;You see a &quot; + @colour + &quot; dog.&quot;
  end
end

# We can&apos;t see @colour from outside instances of the Dog class
# Here, we&apos;re trying to access @colour from the main object
# It can&apos;t see the instance variable @colour
@colour
</code></pre>
<blockquote>
<p>If you try to reference an <em>instance</em> variable that an object can&apos;t see, you&apos;ll get <code>nil</code>.</p>
</blockquote>
<h4 id="what-can-see-a-local-variable">What can see a local variable?</h4>
<p><strong>Regular variables</strong> are normally referred to as <strong>local variables</strong>. Here, we&apos;re in imperative-land: telling the computer what to do, line-by-line.</p>
<p>If a line defining that local variable <em>has already been executed</em>, that local variable is available to anything that wants it.</p>
<pre><code class="lang-eval-ruby"># Define a local variable in the main program object
my_variable = 1

# We can access the local variable here, because the line above was executed before this one
my_variable
</code></pre>
<animation showing="" local="" variables="">

<p>This is the case even if the local variable was defined in a conditional branch that got executed:</p>
<pre><code class="lang-eval-ruby">if true
  # This conditional branch will be executed
  my_variable = 1
end

my_variable
</code></pre>
<p>One gotcha &#x2013; strange things happen if you define variables in branches that <em>don&apos;t</em> get executed:</p>
<pre><code class="lang-eval-ruby">if false
  my_variable = 1
end

my_variable
</code></pre>
<p>The program can still read the name: but the value is set to <code>nil</code>.</p>
<p>There&apos;s one really tricky thing about local variables, and it has to do with methods. Here it is:</p>
<pre><code class="lang-eval-ruby">def my_method
  my_variable = 1
end

my_variable
</code></pre>
<p>Why can&apos;t the main object see the <code>my_variable</code> variable, even though it was defined in the lines above? The answer that most makes sense: <code>my_method</code> didn&apos;t get executed yet. We only declared it, but we didn&apos;t call the method.</p>
<p>So we can solve it like this, right?</p>
<pre><code class="lang-eval-ruby"># define the method
def my_method
  my_variable = 1
end

# run the method, executing the procedure that defines my_variable
my_method

my_variable
</code></pre>
<p>Wrong. For some reason &#x2013; even though the procedure <code>my_variable = 1</code> (inside the method <code>my_method</code>) has been executed &#x2013; the main object still can&apos;t see <code>my_variable</code>. Why is this?</p>
<h2 id="scope">Scope</h2>
<p>Every time we write one of the following:</p>
<ul>
<li><code>def</code></li>
<li><code>class</code></li>
</ul>
<p>We &apos;open&apos; something.</p>
<ul>
<li><code>def</code> opens a method, so we can define a procedure inside.</li>
<li><code>class</code> opens a new class, so we can define methods inside.</li>
</ul>
<p>The keyword <code>end</code> then &apos;closes&apos; that something you just opened.</p>
<pre><code class="lang-eval-ruby">def average
  # we opened the average method, so we can define procedures in it
end

class Dog
  # we opened the Dog class, so we can define methods in it
end
</code></pre>
<p>Variables that we define inside a <code>def...end</code> or <code>class...end</code> cannot be seen outside of them:</p>
<pre><code class="lang-eval-ruby">def average
  accumulator = 0
end

class Dog
  some_variable = 1
end

puts accumulator
puts some_variable
</code></pre>
<p>The area of a program in which a variable can be read is called the variable <strong>scope</strong>. <code>def</code> and <code>class</code> are known as <strong>scope gates</strong>: when the program runs a line containing <code>def</code> or <code>class</code>, it enters a new scope. Variables defined inside this scope cannot be read outside of the scope gate. Variables defined outside of the scope gate cannot be read inside it.</p>
<pre><code class="lang-eval-ruby">my_variable = 1

def my_method
  # I&apos;m in a new scope gate! I can&apos;t read my_variables
  my_variable + my_variable
end

my_method
</code></pre>
<p>Here&apos;s a visual representation of scope:</p>
<diagram of="" code="" with="" highlighted="" scope="" and="" out="">

<blockquote>
<p>Confused by the word &apos;scope&apos;? Think of the scope on top of a sniper-rifle: when you look down it, you can only see a part of the world: the part of the world you can shoot.</p>
</blockquote>
<p>One more gotcha: even though files containing Ruby code are all loaded into the program straight away, local variables cannot be read from outside of the file they&apos;re declared in. So files act as scope gates, too.</p>
<h2 id="using-scope-to-understand-method-parameters">Using scope to understand method parameters</h2>
<p>Scope is especially helpful when it comes to understanding method parameters. For each parameter, methods will define a local variable within their scope. The name of that variable will be set to the name of the parameter:</p>
<pre><code class="lang-eval-ruby">age = 22

def age_reporter(number)
  # Whatever we pass as an argument to age_reporter will be assigned to a local variable named &apos;number&apos;
  return &quot;Your age is &quot; + number.to_s
end

age_reporter(age)
</code></pre>
<p>The same goes for parameters provided to procedures inside <code>each</code> loops:</p>
<pre><code class="lang-eval-ruby">people = [&quot;Steve&quot;, &quot;Yasmin&quot;, &quot;Alex&quot;]

people.each do |name|
  # Each element of people is assigned to a local variable called &apos;name&apos;
  # We can then read that local variable inside this loop
  puts name
end

# But we can&apos;t read the local variable outside the loop
puts name
</code></pre>
<p>Since <code>def</code> is a scope gate, we can&apos;t read these parameters outside of their message body:</p>
<pre><code class="lang-eval-ruby">name = &quot;Sam&quot;

def say_hi_to(person)
  return &quot;Hi, &quot; + person
end

# We can&apos;t read this
person
</code></pre>
<p><a href="https://www.sitepoint.com/understanding-scope-in-ruby/" target="_blank">This article</a> dives a little deeper into the idea of &apos;scope&apos; in Ruby.</p>
<ul>
<li><strong>Scope</strong> is what parts of the program an object can &apos;see&apos; at any time.</li>
</ul>
<h2 id="using-objects-to-be-more-declarative">Using Objects to be more declarative</h2>
<p>By defining our own classes, we can make our programs super-readable: almost like English. Here&apos;s an example:</p>
<pre><code class="lang-ruby">heathrow = Airport.new
plane = Plane.new

heathrow.land(plane)

heathrow.hangar_report
<span class="hljs-comment"># =&gt; &quot;There is 1 plane in the hangar&quot;</span>
</code></pre>
<p>Also, we can stop programmers from doing things that don&apos;t fit with our model of how the program should work:</p>
<pre><code class="lang-ruby">heathrow = Airport.new

heathrow.take_off(plane)
<span class="hljs-comment"># =&gt; &quot;Error: There are no planes to take off&quot;</span>
</code></pre>
<p>In the examples above, the object referenced by <code>heathrow</code> is an instance of the <code>Airport</code> class. Somehow, it can store planes. At the heart of the <code>heathrow</code> object, in its state, lives an array &#x2013; an object we introduced in <a href="../chapter7/">Chapter 7</a> as a way to store other objects. Around this array, <code>heathrow</code> defines methods which are appropriately-named for the program being run &#x2013; some sort of airport simulation. Here, the &apos;airport simulation&apos; is known as the program <strong>domain</strong>.</p>
<p>Why don&apos;t we just use an array, instead of instaces of this <code>Airport</code> class? That way, the program could work like this:</p>
<pre><code class="lang-ruby">heathrow = []
plane = <span class="hljs-string">&quot;Boeing 737&quot;</span>

heathrow.push(plane)

<span class="hljs-string">&quot;There is <span class="hljs-subst">#{ heathrow.length }</span> plane in the hangar&quot;</span>
</code></pre>
<p>The answer is: the second describes the program domain less effectively. As programmers, we strive to write code that accurately reflects the program domain.</p>
<p>Here&apos;s how <code>Airport</code> &apos;wraps&apos; an array:</p>
<pre><code class="lang-eval-ruby">class Airport
  def initialize
    @hangar = []
  end

  def land(plane)
    @hangar.push(plane)
  end

  def take_off(plane)
    if @hanger.length &gt; 0
      if @hangar.includes? plane
        plane_index = @hangar.index(plane)
        @hangar.delete_at(plane_index)
        return plane
      else
        return &quot;Error: plane not in hangar&quot;
      end
    else
      return &quot;Error: there are no planes to take off&quot;
    end
  end

  def hangar_report
    if @hangar.length == 1
      &quot;There is 1 plane in the hangar&quot;
    else
      &quot;There are #{ @hanger.length } planes in the hangar&quot;
    end
  end
end
</code></pre>
<p>Because the array is referenced only by an <em>instance variable</em>, nothing outside of <code>Airport</code> instances can read it: so we&apos;re protected from programmers trying to <code>pop</code> a plane from <code>heathrow</code>, and so on. This essentially <em>limits the interface of the array</em> to only methods we want to allow.</p>
<blockquote>
<p>Spend some time playing with the code example above. Write a <code>Plane</code> class if you can &#x2013; get the initial code example running. The code here is similar to code introduced in the first week of Makers Academy, so don&apos;t worry if it boggles you at the moment.</p>
</blockquote>
<h2 id="complete-the-mastery-quiz-for-chapter-10">Complete the mastery quiz for chapter 10</h2>
<p>Use your mastery quizzes repository to complete the quiz for chapter 10.</p>
 <link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css"> <script>     window.klipse_settings = {         selector: ".language-klipse, .lang-eval-clojure",         selector_eval_js: ".lang-eval-js",         selector_eval_python_client: ".lang-eval-python",         selector_eval_php: ".lang-eval-php",         selector_eval_scheme: ".lang-eval-scheme",         selector_eval_ruby: ".lang-eval-ruby",         selector_reagent: ".lang-reagent",        selector_google_charts: ".lang-google-chart",        selector_es2017: ".lang-eval-es2017",        selector_jsx: ".lang-eval-jsx",        selector_transpile_jsx: ".lang-transpile-jsx",        selector_render_jsx: ".lang-render-jsx",        selector_react: ".lang-react",        selector_eval_markdown: ".lang-render-markdown",        selector_eval_lambdaway: ".lang-render-lambdaway",        selector_eval_cpp: ".lang-eval-cpp",        selector_eval_html: ".lang-render-html",        selector_sql: ".lang-eval-sql",        selector_brainfuck: "lang-eval-brainfuck",        selector_js: ".lang-transpile-cljs"    }; </script> <script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script></diagram></animation></diagram></zoom></objects>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../chapter9/" class="navigation navigation-prev navigation-unique" aria-label="Previous page: Methods">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Classes","level":"1.12","depth":1,"previous":{"title":"Methods","level":"1.11","depth":1,"path":"chapter9/README.md","ref":"./chapter9/README.md","articles":[]},"dir":"ltr"},"config":{"plugins":["klipse","accordion","disqus"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"disqus":{"useIdentifier":false,"shortName":"makers-mastery"},"accordion":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"klipse":{"myConfigKey":"it's the default value"},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Mary Rose Cook and Sam Morgan","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Mastery Curriculum","gitbook":"*","description":"The Mastery Curriculum for the Makers Academy PreCourse."},"file":{"path":"chapter10/README.md","mtime":"2019-04-02T13:52:35.329Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-04-10T14:24:39.836Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-accordion/accordionSelector.js"></script>
        
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/URI.js/1.16.1/URI.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-disqus/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

